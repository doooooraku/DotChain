# 3_詳細設計書（DotChain v1.0）

---

## 1. 本書の位置づけと目的

本書「3_詳細設計書.md」は、DotChain v1.0 の**実装レベルの設計**をまとめたドキュメントです。

- 0_プロダクト戦略.md … 何のためのアプリか（目的 / KPI）
- 1_基本仕様書.md … 何ができるアプリか（F-01〜F-07）
- 1.5_UI_画面設計書.md … 画面に何がどう並ぶか（S-01〜S-04）
- 2_機能設計書.md … 各機能がどう動くか（フロー・分岐）
- **3_詳細設計書.md … 実際にどうコードとして作るか（データ構造・ストア・コンポーネント構成・サービス層）**

という関係です。

このファイルだけで、

- TypeScript でどのような型・Store・サービス関数を持つか
- 画面ごとのコンポーネント構造
- RevenueCat / AdMob / i18n とのつなぎこみの粒度

まで分かる状態を目標にします。

---

## 2. 全体アーキテクチャ

### 2-1. 技術スタック（前提）

- 言語：TypeScript
- フレームワーク：React Native + Expo
- UIライブラリ：Tamagui
- ルーティング：Expo Router（`app/` ディレクトリベース）
- 状態管理：Zustand（または同等の軽量Store）
- 永続化：
  - 設定・Pro状態：SecureStore / AsyncStorage
  - 習慣・記録：SQLite（`expo-sqlite` など）
- 課金：RevenueCat
- 広告：Google AdMob（バナー広告）
- 多言語化：i18next + react-i18next（想定）

> 用語メモ
> - **フレームワーク**：アプリを作るための「枠組み」となるソフトウェア。
> - **ライブラリ**：特定の機能を提供する部品集。
> - **状態管理（State Management）**：アプリの中で「今のデータ（状態）」をどこで・どう持つかを管理する仕組み。

### 2-2. レイヤ構造

大きく以下のレイヤに分けます。

1. **Presentation（画面 / コンポーネント）レイヤ**
   - 例：`HomeScreen`, `SettingsScreen`, `HabitEditScreen`, `ProScreen`
2. **Store（状態管理）レイヤ**
   - 例：`useHabitStore`, `useSettingsStore`, `useProStore`, `useUiStore`
3. **Service（サービス）レイヤ**
   - 例：`HabitRepository`, `LogRepository`, `RevenueCatService`, `AdsService`, `I18nService`
4. **Infra（インフラ）レイヤ**
   - DB・SecureStore・HTTPなどの実際の外部システムとのやりとり

依存の方向は **上から下のみ** を許容します。

- 画面 → Store → Repository / Service → DB / SDK
- 逆方向の依存は作らない（例：Repository から画面コンポーネントを呼ばない）。

---

## 3. ディレクトリ構成（例）

実際のリポジトリ構成に合わせて読み替え可能ですが、v1.0の推奨構成を示します。

```text
src/
  app/                  # 画面（Expo Router）
    index.tsx           # S-01 ホーム
    settings.tsx        # S-02 設定
    habit-edit.tsx      # S-03 習慣編集
    pro.tsx             # S-04 Proプラン画面
  components/           # 再利用UIコンポーネント
    HabitListItem.tsx
    HeatmapCalendar.tsx
    ThemeSelector.tsx
    LanguageSelector.tsx
    AdBanner.tsx
    Toast.tsx
  stores/               # Zustand ストア
    habitStore.ts
    logStore.ts
    settingsStore.ts
    proStore.ts
    uiStore.ts
  services/             # ドメインロジック・外部サービス
    habitRepository.ts
    logRepository.ts
    settingsRepository.ts
    proService.ts       # RevenueCat 連携
    adsService.ts       # AdMob 連携
    i18n.ts             # 多言語
    dateService.ts      # 日付ヘルパー
  db/
    schema.sql          # SQLiteテーブル定義
    sqliteClient.ts
  types/
    models.ts           # 型定義（Habit, HabitLog など）
  utils/
    logger.ts
    errorHandler.ts
```

> 用語メモ
> - **Repository（リポジトリ）**：DBへの保存・取得処理をまとめた層。画面やStoreからは「DBの中身」を意識せずに操作できる。

---

## 4. 型定義（TypeScript モデル）

### 4-1. 基本モデル

```ts
// src/types/models.ts

export type HabitId = string;
export type ISODateString = string; // "YYYY-MM-DD"

export interface Habit {
  id: HabitId;
  name: string;          // 最大30文字など
  iconKey: string;       // "book", "dumbbell" など
  colorKey: string;      // "green", "pink" など
  createdAt: string;     // ISO8601日時文字列
  updatedAt: string;     // ISO8601日時文字列
}

export type HabitLogStatus = "done" | "not_done";

export interface HabitLog {
  habitId: HabitId;
  date: ISODateString;   // 端末ローカル日付のキー
  status: HabitLogStatus;
  updatedAt: string;
}

export type ThemeKey = "dark" | "neonPink" | "cyberBlue";

export type LanguageCode =
  | "en"
  | "ja"
  | "fr"
  | "es"
  | "de"
  | "it"
  | "pt"
  | "ru"
  | "zhHans"
  | "zhHant"
  | "ko"
  | "th"
  | "id"
  | "vi"
  | "hi"
  | "tr"
  | "pl"
  | "sv";

export type HeatmapDaysOption = 30 | 60 | 180 | 365;

/**
 * アプリの見た目・通知に関する設定
 * - 言語は i18n ストアで管理するため含めない
 */
export interface SettingsState {
  theme: ThemeKey; // 'dark' | 'neonPink' | 'cyberBlue'
  sound: boolean;
  haptics: boolean;
  tapSound: 'click' | 'pop';
  hasSeenOnboarding: boolean;
  heatmapDays: HeatmapDaysOption;
  electricFlow: boolean; // ヒートマップの電流アニメON/OFF
  hasRequestedReview: boolean;
  isPro: boolean;
  reminderEnabled: boolean;
  reminderTime: string; // "HH:MM"
}

export interface ProState {
  isPro: boolean;
  anonUserId: string | null;
  lastCheckAt: string | null; // 最終同期日時
}

export type ToastType = "info" | "error";

export interface ToastMessage {
  id: string;
  type: ToastType;
  message: string;
}
```

> 単語メモ
> - **interface**：オブジェクトの「形（どんなプロパティを持つか）」を定義する構文。
> - **type**：型に別名をつける仕組み。複数の文字列をまとめて一つの型として定義できる。

---

## 5. ローカルDB設計（SQLite）

### 5-1. テーブル一覧

- `habits` … 習慣マスタ
- `habit_logs` … 日別の記録

### 5-2. テーブル定義（例）

`db/schema.sql` のイメージ：

```sql
CREATE TABLE IF NOT EXISTS habits (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  icon_key TEXT NOT NULL,
  color_key TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS habit_logs (
  habit_id TEXT NOT NULL,
  date TEXT NOT NULL,
  status TEXT NOT NULL CHECK(status IN ('done', 'not_done')),
  updated_at TEXT NOT NULL,
  PRIMARY KEY (habit_id, date),
  FOREIGN KEY (habit_id) REFERENCES habits(id) ON DELETE CASCADE
);
```

> 単語メモ
> - **PRIMARY KEY**：そのテーブルの中で一意になる列（または列の組）を指定する。
> - **FOREIGN KEY**：別テーブルのPRIMARY KEYを参照する列。ここでは`habit_logs.habit_id`が`habits.id`を参照。
> - **ON DELETE CASCADE**：親テーブルの行が消えた時、紐づく子行も自動で削除する。

---

## 6. Store（状態管理）設計

状態管理には Zustand を想定します。`create()` でStoreを定義し、画面コンポーネントから `useXxxStore()` で参照します。

### 6-1. HabitStore（習慣）

```ts
// src/stores/habitStore.ts
import { create } from "zustand";
import { Habit, HabitId } from "@/types/models";
import { habitRepository } from "@/services/habitRepository";

interface HabitState {
  habits: Habit[];
  isLoading: boolean;
  loadHabits: () => Promise<void>;
  addHabit: (input: Omit<Habit, "id" | "createdAt" | "updatedAt">) => Promise<void>;
  updateHabit: (id: HabitId, patch: Partial<Habit>) => Promise<void>;
  deleteHabit: (id: HabitId) => Promise<void>;
}

export const useHabitStore = create<HabitState>((set, get) => ({
  habits: [],
  isLoading: false,

  async loadHabits() {
    set({ isLoading: true });
    const list = await habitRepository.getAll();
    set({ habits: list, isLoading: false });
  },

  async addHabit(input) {
    const habit = await habitRepository.create(input);
    set({ habits: [...get().habits, habit] });
  },

  async updateHabit(id, patch) {
    const updated = await habitRepository.update(id, patch);
    set({
      habits: get().habits.map(h => (h.id === id ? updated : h)),
    });
  },

  async deleteHabit(id) {
    await habitRepository.delete(id);
    set({ habits: get().habits.filter(h => h.id !== id) });
  },
}));
```

ポイント：

- DBへのアクセスは `habitRepository` に閉じ込める。
- 画面は Store を叩くだけでよく、SQL を意識しない。

#### 6-1-1. 集計セレクタ（連続日数 / All Done 日数）

- `selectStreak(state): number`
  - 目的: ホーム画面の「連続日数（daysStreak）」表示用に、**現在の連続達成日数**を算出する。
  - 処理: 今日から1日ずつ過去へさかのぼり、「その日に1件でも達成ログがあるか」を確認。初めて「達成ゼロの日」が出た時点で終了。さかのぼる範囲は、`logs` に登場する最も古い日付まで（任意の上限は設けない）。
- `selectAllDoneDays(state): number`
  - 目的: ホーム画面の「All Done 日数」表示用に、**通算で全習慣を達成できた日数**を算出する。
  - 処理: 各習慣の作成日を日付キーに変換し、ある日付 `D` について「作成日 <= D の習慣」を対象習慣とする。対象習慣すべてにその日の達成ログがある場合のみ 1 日としてカウントし、合計を返す。

### 6-2. LogStore（記録）

```ts
// src/stores/logStore.ts
import { create } from "zustand";
import { HabitLog, HabitId, ISODateString } from "@/types/models";
import { logRepository } from "@/services/logRepository";
import { useUiStore } from "@/stores/uiStore";

interface LogState {
  logsByDate: Record<ISODateString, HabitLog[]>;
  toggleTodayStatus: (habitId: HabitId, date: ISODateString) => Promise<void>;
  loadRange: (from: ISODateString, to: ISODateString) => Promise<void>;
}

export const useLogStore = create<LogState>((set, get) => ({
  logsByDate: {},

  async loadRange(from, to) {
    const logs = await logRepository.getRange(from, to);
    const grouped: Record<ISODateString, HabitLog[]> = {};
    for (const log of logs) {
      if (!grouped[log.date]) grouped[log.date] = [];
      grouped[log.date].push(log);
    }
    set({ logsByDate: grouped });
  },

  async toggleTodayStatus(habitId, date) {
    try {
      const current = await logRepository.get(habitId, date);
      const nextStatus: HabitLog["status"] = current?.status === "done" ? "not_done" : "done";
      const updated = await logRepository.upsert({ habitId, date, status: nextStatus });

      // ローカル状態更新（簡略化）
      const currentByDate = get().logsByDate[date] ?? [];
      const without = currentByDate.filter(l => l.habitId !== habitId);
      const nextList = [...without, updated];
      set({
        logsByDate: {
          ...get().logsByDate,
          [date]: nextList,
        },
      });
    } catch (e) {
      useUiStore.getState().showToast({
        type: "error",
        message: "保存に失敗しました",
      });
      throw e;
    }
  },
}));
```

### 6-3. SettingsStore（設定）

```ts
// src/stores/settingsStore.ts（抜粋）
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import AsyncStorage from "@react-native-async-storage/async-storage";

type HeatmapDaysOption = 30 | 60 | 180 | 365;

type SettingsState = {
  sound: boolean;
  haptics: boolean;
  theme: 'dark' | 'neonPink' | 'cyberBlue';
  tapSound: 'click' | 'pop';
  hasSeenOnboarding: boolean;
  heatmapDays: HeatmapDaysOption;
  electricFlow: boolean;
  hasRequestedReview: boolean;
  isPro: boolean;
  reminderEnabled: boolean;
  reminderTime: string;
  setSound: (v: boolean) => void;
  setHaptics: (v: boolean) => void;
  setTheme: (v: SettingsState['theme']) => void;
  setTapSound: (v: SettingsState['tapSound']) => void;
  setHasSeenOnboarding: (v: boolean) => void;
  setHeatmapDays: (days: HeatmapDaysOption) => void;
  setElectricFlow: (v: boolean) => void;
  setHasRequestedReview: (v: boolean) => void;
  setIsPro: (v: boolean) => void;
  setReminderEnabled: (v: boolean) => Promise<void>;
  setReminderTime: (time: string) => Promise<void>;
};

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      sound: true,
      haptics: true,
      theme: 'dark',
      tapSound: 'click',
      hasSeenOnboarding: false,
      heatmapDays: 60,
      electricFlow: true,
      hasRequestedReview: false,
      isPro: false,
      reminderEnabled: false,
      reminderTime: '08:00',
      setSound: (v) => set({ sound: v }),
      setHaptics: (v) => set({ haptics: v }),
      setTheme: (v) => set({ theme: v }),
      setTapSound: (v) => set({ tapSound: v }),
      setHasSeenOnboarding: (v) => set({ hasSeenOnboarding: v }),
      setHeatmapDays: (days) => {
        const allowed: HeatmapDaysOption[] = [30, 60, 180, 365];
        set({ heatmapDays: allowed.includes(days) ? days : 60 });
      },
      setElectricFlow: (v) => set({ electricFlow: Boolean(v) }),
      setHasRequestedReview: (v) => set({ hasRequestedReview: Boolean(v) }),
      setIsPro: (v) => set({ isPro: Boolean(v) }),
      setReminderEnabled: async (v) => {
        set({ reminderEnabled: Boolean(v) });
        // 通知スケジュールは NotificationManager に委譲
      },
      setReminderTime: async (time) => {
        set({ reminderTime: time });
        // 通知スケジュールは NotificationManager に委譲
      },
    }),
    {
      name: "dotchain-settings",
      storage: createJSONStorage(() => AsyncStorage),
    },
  ),
);
```

### 6-4. ProStore（課金状態）

```ts
// src/stores/proStore.ts
import { create } from "zustand";
import { ProState } from "@/types/models";
import { proService } from "@/services/proService";

interface ProStoreState extends ProState {
  isLoading: boolean;
  init: () => Promise<void>;      // 起動時に呼ぶ
  purchaseMonthly: () => Promise<void>;
  purchaseYearly: () => Promise<void>;
  restore: () => Promise<void>;
}

export const useProStore = create<ProStoreState>((set, get) => ({
  isPro: false,
  anonUserId: null,
  lastCheckAt: null,
  isLoading: false,

  async init() {
    set({ isLoading: true });
    const state = await proService.loadLocalState();
    if (state) {
      set({ ...state, isLoading: false });
    } else {
      set({ isLoading: false });
    }
  },

  async purchaseMonthly() {
    set({ isLoading: true });
    const state = await proService.purchase("monthly");
    set({ ...state, isLoading: false });
  },

  async purchaseYearly() {
    set({ isLoading: true });
    const state = await proService.purchase("yearly");
    set({ ...state, isLoading: false });
  },

  async restore() {
    set({ isLoading: true });
    const state = await proService.restore();
    set({ ...state, isLoading: false });
  },
}));
```

### 6-5. UiStore（トーストなど）

```ts
// src/stores/uiStore.ts
import { create } from "zustand";
import { ToastMessage } from "@/types/models";

interface UiState {
  toasts: ToastMessage[];
  showToast: (toast: Omit<ToastMessage, "id">) => void;
  removeToast: (id: string) => void;
}

export const useUiStore = create<UiState>((set, get) => ({
  toasts: [],

  showToast(toast) {
    const id = Date.now().toString();
    const msg: ToastMessage = { id, ...toast };
    set({ toasts: [...get().toasts, msg] });
    // 数秒後に自動削除する処理はコンポーネント側でも良い
  },

  removeToast(id) {
    set({ toasts: get().toasts.filter(t => t.id !== id) });
  },
}));
```

---

## 7. Repository / Service 設計

### 7-1. HabitRepository

```ts
// src/services/habitRepository.ts
import { db } from "@/db/sqliteClient";
import { Habit } from "@/types/models";
import { v4 as uuid } from "uuid";

export const habitRepository = {
  async getAll(): Promise<Habit[]> {
    // SQLiteクエリ実装（擬似コード）
    const rows = await db.query("SELECT * FROM habits ORDER BY created_at ASC");
    return rows.map(row => ({
      id: row.id,
      name: row.name,
      iconKey: row.icon_key,
      colorKey: row.color_key,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }));
  },

  async create(input: Omit<Habit, "id" | "createdAt" | "updatedAt">): Promise<Habit> {
    const now = new Date().toISOString();
    const habit: Habit = {
      id: uuid(),
      createdAt: now,
      updatedAt: now,
      ...input,
    };
    await db.execute(
      "INSERT INTO habits (id, name, icon_key, color_key, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)",
      [
        habit.id,
        habit.name,
        habit.iconKey,
        habit.colorKey,
        habit.createdAt,
        habit.updatedAt,
      ],
    );
    return habit;
  },

  async update(id: string, patch: Partial<Habit>): Promise<Habit> {
    const existing = await this.getById(id);
    if (!existing) throw new Error("Habit not found");
    const now = new Date().toISOString();
    const next: Habit = { ...existing, ...patch, updatedAt: now };
    await db.execute(
      "UPDATE habits SET name = ?, icon_key = ?, color_key = ?, updated_at = ? WHERE id = ?",
      [next.name, next.iconKey, next.colorKey, next.updatedAt, id],
    );
    return next;
  },

  async getById(id: string): Promise<Habit | null> {
    const rows = await db.query("SELECT * FROM habits WHERE id = ? LIMIT 1", [id]);
    if (rows.length === 0) return null;
    const row = rows[0];
    return {
      id: row.id,
      name: row.name,
      iconKey: row.icon_key,
      colorKey: row.color_key,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  },

  async delete(id: string): Promise<void> {
    await db.execute("DELETE FROM habits WHERE id = ?", [id]);
    // ON DELETE CASCADE によりログも削除される想定
  },
};
```

### 7-2. LogRepository

```ts
// src/services/logRepository.ts
import { db } from "@/db/sqliteClient";
import { HabitLog, HabitId, ISODateString } from "@/types/models";

export const logRepository = {
  async get(habitId: HabitId, date: ISODateString): Promise<HabitLog | null> {
    const rows = await db.query(
      "SELECT * FROM habit_logs WHERE habit_id = ? AND date = ? LIMIT 1",
      [habitId, date],
    );
    if (rows.length === 0) return null;
    const row = rows[0];
    return {
      habitId: row.habit_id,
      date: row.date,
      status: row.status,
      updatedAt: row.updated_at,
    };
  },

  async getRange(from: ISODateString, to: ISODateString): Promise<HabitLog[]> {
    const rows = await db.query(
      "SELECT * FROM habit_logs WHERE date BETWEEN ? AND ?",
      [from, to],
    );
    return rows.map(row => ({
      habitId: row.habit_id,
      date: row.date,
      status: row.status,
      updatedAt: row.updated_at,
    }));
  },

  async upsert(log: Omit<HabitLog, "updatedAt">): Promise<HabitLog> {
    const now = new Date().toISOString();
    await db.execute(
      "INSERT INTO habit_logs (habit_id, date, status, updated_at) VALUES (?, ?, ?, ?) " +
        "ON CONFLICT(habit_id, date) DO UPDATE SET status = excluded.status, updated_at = excluded.updated_at",
      [log.habitId, log.date, log.status, now],
    );
    return { ...log, updatedAt: now };
  },
};
```

### 7-3. SettingsRepository

```ts
// src/services/settingsRepository.ts
import * as SecureStore from "expo-secure-store";
import { Settings } from "@/types/models";

const SETTINGS_KEY = "dotchain_settings_v1";

export const settingsRepository = {
  async load(): Promise<Settings | null> {
    const raw = await SecureStore.getItemAsync(SETTINGS_KEY);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as Settings;
    } catch {
      return null;
    }
  },

  async save(settings: Settings): Promise<void> {
    await SecureStore.setItemAsync(SETTINGS_KEY, JSON.stringify(settings));
  },
};
```

### 7-4. ProService（RevenueCat 連携）

```ts
// src/services/proService.ts
import * as SecureStore from "expo-secure-store";
import { ProState } from "@/types/models";
import { Purchases } from "react-native-purchases"; // RevenueCat SDK を想定

const PRO_KEY = "dotchain_pro_state_v1";

export type PlanType = "monthly" | "yearly";

async function saveState(state: ProState) {
  await SecureStore.setItemAsync(PRO_KEY, JSON.stringify(state));
}

export const proService = {
  async loadLocalState(): Promise<ProState | null> {
    const raw = await SecureStore.getItemAsync(PRO_KEY);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as ProState;
    } catch {
      return null;
    }
  },

  async purchase(plan: PlanType): Promise<ProState> {
    // RevenueCatでのプランID取得は別途設定ファイルから
    const offeringId = plan === "monthly" ? "dotchain_monthly" : "dotchain_yearly";

    const { customerInfo } = await Purchases.purchasePackage(/* offeringIdに応じたパッケージ */);
    const isPro = typeof customerInfo.entitlements.active["pro"] !== "undefined";

    const next: ProState = {
      isPro,
      anonUserId: customerInfo.originalAppUserId,
      lastCheckAt: new Date().toISOString(),
    };
    await saveState(next);
    return next;
  },

  async restore(): Promise<ProState> {
    const { customerInfo } = await Purchases.restorePurchases();
    const isPro = typeof customerInfo.entitlements.active["pro"] !== "undefined";
    const next: ProState = {
      isPro,
      anonUserId: customerInfo.originalAppUserId,
      lastCheckAt: new Date().toISOString(),
    };
    await saveState(next);
    return next;
  },
};
```

> 単語メモ
> - **SDK（Software Development Kit）**：特定のサービスをアプリから簡単に使えるようにまとめた「道具箱」。
> - **entitlements**：RevenueCatで「このユーザーはどの権利（Proなど）を持っているか」を表す情報。

### 7-5. AdsService（AdMob）

実装はコンポーネント寄りになりますが、ラッパーコンポーネントを用意しておきます。

```tsx
// src/components/AdBanner.tsx
import { BannerAd, BannerAdSize, TestIds } from "react-native-google-mobile-ads";
import { useProStore } from "@/stores/proStore";

const REAL_AD_UNIT_ID = "ca-app-pub-xxxxxxxxxxxxxxxx/xxxxxxxxxx"; // 実値は別管理

export function AdBanner() {
  const isPro = useProStore(state => state.isPro);
  if (isPro) return null;

  const unitId = __DEV__ ? TestIds.BANNER : REAL_AD_UNIT_ID;

  return <BannerAd unitId={unitId} size={BannerAdSize.BANNER} />;
}
```

---

## 8. 画面コンポーネント構成

### 8-1. S-01 HomeScreen

```tsx
// src/app/index.tsx

import { useEffect } from "react";
import { View, ScrollView } from "react-native";
import { useHabitStore } from "@/stores/habitStore";
import { useLogStore } from "@/stores/logStore";
import { useSettingsStore } from "@/stores/settingsStore";
import { useProStore } from "@/stores/proStore";
import { HabitList } from "@/components/HabitList";
import { HeatmapCalendar } from "@/components/HeatmapCalendar";
import { AdBanner } from "@/components/AdBanner";

export default function HomeScreen() {
  const { habits, loadHabits } = useHabitStore();
  const { settings } = useSettingsStore();
  const { loadRange } = useLogStore();
  const { isPro, init } = useProStore();

  useEffect(() => {
    // 起動時に必要なデータをまとめて読み込む
    init();
    loadHabits();
    // ヒートマップ用の期間をロード
    const today = /* dateService.today() */ "2025-11-30" as const; // 実装では動的
    const from = /* today - settings.heatmapRangeDays */ today;
    loadRange(from, today);
  }, []);

  return (
    <View style={{ flex: 1 }}>
      {/* ヘッダー */}
      {/* 今日の概要 */}
      <ScrollView>
        <HabitList />
        <HeatmapCalendar />
      </ScrollView>
      <AdBanner />
      {/* 右下FABは別コンポーネント */}
    </View>
  );
}
```

### 8-2. HabitList コンポーネント

```tsx
// src/components/HabitList.tsx
import { View, FlatList } from "react-native";
import { useHabitStore } from "@/stores/habitStore";
import { useLogStore } from "@/stores/logStore";
import { useDateService } from "@/services/dateService";
import { HabitListItem } from "@/components/HabitListItem";

export function HabitList() {
  const { habits } = useHabitStore();
  const { toggleTodayStatus } = useLogStore();
  const today = useDateService().todayKey();

  if (habits.length === 0) {
    // 「最初の習慣を追加」カードを表示
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={item => item.id}
      renderItem={({ item }) => (
        <HabitListItem
          habit={item}
          onToggle={() => toggleTodayStatus(item.id, today)}
          onEdit={() => {/* ナビゲーションで S-03へ */}}
        />
      )}
    />
  );
}
```

### 8-3. S-02 SettingsScreen

- `useSettingsStore` と `useProStore` を参照し、
  - Proバッジ表示
  - テーマ選択（Free時はタップで S-04 へ）
  - 言語選択（i18n 切替）
  - 効果音 / 振動 / エフェクト トグル
  - ヒートマップ日数 選択
  - 「購入を復元」ボタン → `useProStore().restore()`

### 8-4. S-03 HabitEditScreen

- パラメータで `habitId` を受け取り、
  - ある場合：編集モード
  - ない場合：新規作成
- 保存ボタン押下時：
  - Free & 3件以上なら `Alert` 表示のみ（F-02の仕様どおり save しない）
  - そうでなければ `useHabitStore().addHabit()` or `updateHabit()`

### 8-5. S-04 ProScreen

- `useProStore` から `isPro`, `isLoading`, `purchaseMonthly`, `purchaseYearly` を取得。
- Free時：
  - 比較表 + プランカード（タップで `purchaseXXX` 呼び出し）。
- Pro時：
  - 上部に「すでに Pro プランが有効です」の文言。

---

## 9. エラーハンドリング / ロギング方針

### 9-1. エラー種別

- ユーザー操作エラー（バリデーション）：
  - 例：習慣名が空のまま保存
  - 対応：トースト＋入力欄の強調表示

- 永続化エラー（DB / SecureStore）：
  - 例：ログの保存失敗
  - 対応：トースト（「保存に失敗しました」）＋コンソールログ

- ネットワークエラー（RevenueCat, AdMob）：
  - 対応：
    - 課金：トーストでエラー通知（Alertではない）
    - 広告：ユーザーには何も見せない（静かに失敗）

### 9-2. logger / errorHandler

```ts
// src/utils/logger.ts
export const logger = {
  info: (...args: unknown[]) => {
    if (__DEV__) {
      console.log("[INFO]", ...args);
    }
  },
  error: (...args: unknown[]) => {
    console.error("[ERROR]", ...args);
  },
};
```

```ts
// src/utils/errorHandler.ts
import { logger } from "./logger";
import { useUiStore } from "@/stores/uiStore";

export function handleError(e: unknown, messageForUser?: string) {
  logger.error(e);
  if (messageForUser) {
    useUiStore.getState().showToast({ type: "error", message: messageForUser });
  }
}
```

---

## 10. パフォーマンス / 非機能要件への対策

### 10-1. パフォーマンス

- ホーム画面初期表示で行う DB 読み込みを最小限に：
  - 最初は「今日〜Heatmap範囲」のログのみ取得。
  - Habit数が増えても、`FlatList` の `keyExtractor` を適切に設定し、行再レンダリングを抑制。

- 不必要な Re-render を防ぐ：
  - コンポーネントを小さく分け、必要な Store の一部だけを `useXxxStore(selector)` で参照。

### 10-2. セキュリティ

- ProState / Settings は SecureStore を使用し、平文で外部に流れないようにする。
- APIキー（RevenueCat, AdMob）の値は `.env` などから注入し、Git管理しない。

---

## 11. 開発コマンドと意味（整理）

> すでに他の仕様書にも出てきていますが、ここでは「なぜ使うか」という視点も含めて整理します。

### 11-1. 依存ライブラリを入れる

```bash
pnpm install
```

- `pnpm`：Node.js用のパッケージマネージャ（ライブラリ管理ツール）。
- 役割：`package.json` に書いてあるライブラリをまとめてダウンロードし、`node_modules` フォルダに配置する。

### 11-2. 開発サーバを立ち上げる

```bash
pnpm expo start
```

- `expo`：React Native アプリを簡単に動かすためのツール。
- 役割：QRコードを表示し、スマホアプリ（Expo Go）やエミュレータでアプリを起動できるようにする。

### 11-3. 実機 / エミュレータでビルド

```bash
pnpm expo run:ios
pnpm expo run:android
```

- 役割：
  - iOS / Android の本番に近い形でビルドして動作確認する。
  - 単なる `expo start` よりも実際のストア配布に近い状態でテストできる。

### 11-4. テスト実行

```bash
pnpm test
```

- 役割：
  - ユニットテストやコンポーネントテストを実行し、「大事な処理が壊れていないか」を機械的にチェックする。

### 11-5. E2E テスト（Maestro）

```bash
pnpm maestro test
```

- `Maestro`：アプリを人間が操作するように自動で動かし、画面ごとの動きを確認するツール。
- 役割：
  - 「起動 → 習慣追加 → 今日の記録 → 設定 → Pro画面」など、一連の流れが問題なく動くかを確認できる。

---

## 12. 参考アプリ・資料

機能・設計の参考にしたアプリやサイト：

- Loop Habit Tracker  
  https://loophabits.org/
- Streaks  
  https://streaksapp.com/
- Habitify  
  https://habitify.me/
- Productive  
  https://productiveapp.io/

---

以上が DotChain v1.0 の 3_詳細設計書 の初版です。

このドキュメントをもとに、実装フェーズでは：

- Store / Repository / Service のファイルをこの構造で作成
- 画面コンポーネントから Store を呼び出すかたちで機能を実装

していく前提とします。
