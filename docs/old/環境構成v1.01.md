# 環境構成（DotChain 反映版）
最終更新: 2026-01-11  
対象プロジェクト: DotChain（Expo / React Native）

---

## 0. このドキュメントで「やりたいこと」
DotChain を **いつでも同じ手順で** 開発・ビルド・提出できるように、以下を「決め打ち」します。

- **どの機械・どのOS・どのツール**で作るのか（環境）
- **どの技術で作るのか**（技術構成）
- **どの手順でビルドするのか**（iOS/Android）
- 「何ができる / 何ができない」を先に明確にする（迷子防止）

> ポイント:  
> “多分こうだと思う” を減らすために、各所に **確認コマンド** を載せています。  
> 迷ったら「確認コマンド → 出力を見る → 次の手順へ」で進めます。

---

## 1. まず結論（DotChainの技術構成・環境構成の要点）
### 1-1. 技術構成（アプリ側）
DotChain は次の組み合わせです。

- **Expo SDK 54**（React Native を「Expoの標準」で動かす枠組み）
- **Expo Router**（画面遷移・ルーティングの中心）
- **Tamagui**（UIコンポーネント/テーマ/レスポンシブ）
- **Zustand**（状態管理の中心。軽量なストア）
- **TanStack Query**（サーバー/非同期データのキャッシュ・再取得）
- **expo-sqlite**（端末内DB。オフライン中心のデータ保存）
- **RevenueCat (react-native-purchases)**（サブスク課金）
- **Maestro**（E2Eテスト）
- **Jest**（ユニット/コンポーネントテスト）

### 1-2. 環境構成（開発とビルドの方針）
- **開発環境:** Windows + WSL2(Ubuntu) を中心に開発
- **Android 実機/エミュ:** Windows側でエミュを動かし、WSLから ADB 接続して開発
- **iOS:** WindowsではXcodeが使えないため、**GitHub Actions（macOS）**で iOS ビルド & 提出（TestFlight）を行う
- **配布/提出:** **EAS Build / EAS Submit** を中心に運用（CIから実行）

---

## 2. DotChainの「確定情報」（プロジェクトの中身から見えたこと）
> ここは「ファイルを見て確定できる情報」です。  
> 迷ったら、まずここに戻ると整合が取れます。

### 2-1. 主要ファイル（役割）
- `package.json`
  - 依存パッケージ、スクリプト（実行コマンド）を定義する「設計図」
- `app.json` / `app.config.ts`
  - Expoの設定（アプリ名、アイコン、Bundle ID、権限など）
- `eas.json`
  - EAS Build/EAS Submit の設定（どのプロファイルで何を作るか）
- `.github/workflows/*`
  - GitHub Actions（CI/CDの自動化手順）

### 2-2. package.json から読み取れる要点
- エントリポイント: `expo-router/entry`（Expo Router が起点）
- 主なスクリプト:
  - `pnpm dev` / `pnpm start` → `expo start`
  - `pnpm android` → `expo run:android`
  - `pnpm prebuild` → `expo prebuild`
  - `pnpm build:android` → `expo prebuild --platform android` → `./gradlew bundleRelease`
  - `pnpm test` → `jest`
  - `pnpm test:e2e` → `maestro test ...`

### 2-3. GitHub Actions（iOSビルドの自動化）
DotChain には GitHub Actions のワークフローがあり、概ね次の流れです。

- macOSランナーで依存インストール（Node + pnpm）
- `eas build --platform ios --profile production --local` でIPA生成
- `eas submit -p ios --latest` でTestFlightへ提出

> 重要:  
> CIで `--non-interactive` を使う場合、**事前に App Store Connect のAPIキー設定**が必要になります（後述）。

### 2-4. Expo Doctor の指摘（現状の重要アラート）
あなたのログ（`npx expo-doctor`）では以下が出ています。

1) **「nativeフォルダがあるのに app.config.ts に native設定がある」問題**  
   - `android/` フォルダが存在する場合、EAS Build は `app.json/app.config.ts` の一部設定を自動反映しません。  
   - 例: `orientation`, `icon`, `scheme`, `ios`, `android`, `plugins` などが同期されない可能性があります。

2) **Expo SDK 54 の期待パッチに対して依存が古い**  
   - `expo`, `expo-router`, `expo-notifications` などが “期待値より少し古い” 状態です。  
   - 動くこともありますが、突然の不具合やビルド失敗の原因になりやすいです。

---

## 3. ここが「危ない / 迷子になりやすい」ポイント（改善方針）
### 3-1. Prebuild（CNG）で行くか、Nativeを固定するか
ここが一番大事です。方針がブレると、ビルドが再現できなくなります。

#### **CNG（Prebuild）中心に寄せる**
- ねらい: `android/` や `ios/` を「生成物」として扱い、毎回 `expo prebuild` で作り直す
- メリット:
  - `app.config.ts` の変更が **ビルドに反映されやすい**
  - アプリを増やしても管理が楽（App Factory向き）
- デメリット:
  - native側に直接手で入れた変更は、消える可能性がある  
    → 必要な変更は「Config Plugin化」して残す

**実行のイメージ**
- `android/` をGit管理から外す（.gitignoreに入れる）
- ビルド前に `pnpm prebuild` を実行して生成
- CIも同様に prebuild を含める



---

## 4. 10レイヤーで整理（環境・技術・ビルドを迷子にしない）
> 「上から順に積み木」。上が崩れると下も崩れるので、順番を守るのがコツです。

---

# レイヤー1: OS / 実行環境（Windows + WSL2）
## 役割（何のため？）
- Windows: AndroidエミュレータやGUIを動かしやすい
- WSL2(Ubuntu): 開発用のLinux環境（コマンド、Git、Nodeなど）を揃えやすい

## できること
- WSL内で Node/Expo を動かし、Androidエミュに接続して開発できる

## できないこと（注意）
- Windows/WSL だけでは iOS ビルドができない
  - iOSは macOS でビルドする（GitHub Actions）



# レイヤー2: シェル / 基本ツール（bash, git）
## 役割
- コマンド操作の土台（bash）
- 変更履歴の管理（git）

## よくあるミス
- `~.bashrc` は間違い（ホーム直下にそんなファイルは無い）
- 正解は `~/.bashrc`

## 確認コマンド
```bash
echo $SHELL
cat ~/.bashrc | tail -n 30
git --version
```

---

# レイヤー3: Node.js / パッケージマネージャ（pnpm）
## 役割
- Node.js: JavaScript/TypeScript を動かす「エンジン」
- pnpm: 依存（ライブラリ）を速く・安全に入れる道具


## 重要（Expo SDK 54）
Expo SDK 54 は **Node 20.19.4 以上**が推奨/前提になりやすいです。  
今の v18 で動いても、突然壊れる原因になります。

## 方針
- Nodeは **nvm** で管理し、プロジェクトごとにバージョン固定
- pnpmは **corepack** で固定（CIと揃える）

## 確認コマンド
```bash
node -v
pnpm -v
which node
corepack --version
```

## セットアップ例
```bash
# nvm が入っている前提
nvm install 20
nvm use 20
node -v

# pnpm を corepack で固定する例
corepack enable
corepack prepare pnpm@10.23.0 --activate
pnpm -v
```

---

# レイヤー4: Expo / React Native（開発の心臓）
## 役割
- React Native: スマホアプリを JavaScript/TypeScript で作る仕組み
- Expo: React Native開発をラクにする統合ツール群

## DotChainの特徴
- Expo Router を採用（ファイルベースルーティング）
- expo-dev-client を採用（Expo Goではなく「自分専用の開発用アプリ」も使える）

## 確認コマンド
```bash
npx expo --version
npx expo-doctor
```

## よく使うコマンド
```bash
pnpm dev           # expo start（開発サーバ起動）
pnpm android       # expo run:android（ネイティブ起動/開発ビルド）
pnpm prebuild      # expo prebuild（ネイティブ生成）
```

---

# レイヤー5: 画面遷移・UI（Expo Router + Tamagui）
## 役割
- Expo Router: 画面遷移を「ファイル構造」で管理
- Tamagui: UIを統一（テーマ、余白、レスポンシブ）

## できること
- 画面追加: `app/` 配下にファイルを置くだけでルートが増える（Router）
- デザイン統一: TamaguiのThemeで一括管理

## できないこと（注意）
- ネイティブレベルの極端なUI最適化は、場合によっては追加のネイティブ対応が必要

---

# レイヤー6: 状態管理・データ流れ（Zustand + TanStack Query）
## 役割
- Zustand: 端末内の状態（UI状態、設定、編集中データ）を管理
- TanStack Query: 通信が絡むデータをキャッシュし、更新を自動化

## 使い分け（ざっくり）
- Zustand: 「今この画面で選ばれているもの」など
- Query: 「サーバーから取ってくる一覧」など

---

# レイヤー7: 端末内DB（expo-sqlite）
## 役割
- オフラインでもデータを保持する（端末内のデータベース）

## できること
- オフラインで動く
- データ量が増えても比較的扱いやすい（テキスト保存より強い）

## できないこと（注意）
- 端末を変えるとデータは移行しない（同期機能を別途作る必要）
- 競合解決（複数端末）を自動ではしてくれない

---

# レイヤー8: 外部連携（RevenueCat / Notifications など）
## RevenueCat（課金）
- 役割: サブスク課金（購入状態、レシート検証、クロスプラットフォーム管理）
- 注意: APIキーなどの扱いを間違えると「漏洩」する

### 超重要: EXPO_PUBLIC_ は “公開値” として扱う
- `EXPO_PUBLIC_` で始まる環境変数はアプリに埋め込まれます  
  → 秘密鍵（完全なシークレット）には向きません
- “公開しても良いキーだけ” を入れる、が基本

## Supabase（将来）
-  “将来のオンライン同期” の候補

---

# レイヤー9: ビルド・署名・提出（EAS Build / EAS Submit）
## 役割
- iOS/Android の「ストアに出す形」にまとめる（署名込み）
- CIで自動化して、人間の作業を減らす

## 実装
- iOS/Androidどちらとも最初はEASビルドにて証明書を作成する
- ローカルGradleでAABファイルを作りPlayConsoleでアップロード
- GitHub Actions で iOS を **ローカルビルド（macOS上）**し、提出まで実行

## iOS（TestFlight）基本フロー（おすすめ）
1. **EAS Credentials** で証明書を準備（初回は対話式でやる）
2. **App Store Connect API Key** を設定（CIで非対話実行するため）
3. GitHub Actions で `eas build --local` → `eas submit`

## Android（Play）フロー
### 方式1: ローカルGradle（今の scripts に近い）
- `pnpm build:android` → `bundleRelease` で AAB 作成 

---

# レイヤー10: テスト（Jest / Maestro）
## Jest
- 役割: 関数や部品が壊れていないかを自動で確認
- 実行: `pnpm test`

## Maestro
- 役割: 実際の画面操作を自動で行い、壊れていないか確認
- 実行: `pnpm test:e2e`
---

